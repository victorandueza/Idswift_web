"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.get_security_rules = void 0;
const zod_1 = require("zod");
const apiv2_1 = require("../../../apiv2");
const tool_1 = require("../../tool");
const util_1 = require("../../util");
const rules_1 = require("../../../gcp/rules");
const getDefaultDatabaseInstance_1 = require("../../../getDefaultDatabaseInstance");
exports.get_security_rules = (0, tool_1.tool)({
    name: "get_security_rules",
    description: "Use this to retrieve the security rules for a specified Firebase service. " +
        "If there are multiple instances of that service in the product, the rules for the defualt instance are returned.",
    inputSchema: zod_1.z.object({
        type: zod_1.z.enum(["firestore", "rtdb", "storage"]).describe("The service to get rules for."),
    }),
    annotations: {
        title: "Get Firebase Rules",
        readOnlyHint: true,
    },
    _meta: {
        requiresProject: true,
        requiresAuth: true,
    },
}, async ({ type }, { projectId }) => {
    var _a;
    if (type === "rtdb") {
        const dbUrl = await (0, getDefaultDatabaseInstance_1.getDefaultDatabaseInstance)(projectId);
        if (dbUrl === "") {
            return (0, util_1.mcpError)(`No default RTDB instance found for project ${projectId}`);
        }
        const client = new apiv2_1.Client({ urlPrefix: dbUrl });
        const response = await client.request({
            method: "GET",
            path: "/.settings/rules.json",
            responseType: "stream",
            resolveOnHTTPError: true,
        });
        if (response.status !== 200) {
            return (0, util_1.mcpError)(`Failed to fetch current rules. Code: ${response.status}`);
        }
        const rules = await response.response.text();
        return (0, util_1.toContent)(rules);
    }
    const serviceInfo = {
        firestore: { productName: "Firestore", releaseName: "cloud.firestore" },
        storage: { productName: "Storage", releaseName: "firebase.storage" },
    };
    const { productName, releaseName } = serviceInfo[type];
    const rulesetName = await (0, rules_1.getLatestRulesetName)(projectId, releaseName);
    if (!rulesetName)
        return (0, util_1.mcpError)(`No active ${productName} rules were found in project '${projectId}'`);
    const rules = await (0, rules_1.getRulesetContent)(rulesetName);
    return (0, util_1.toContent)((_a = rules === null || rules === void 0 ? void 0 : rules[0].content) !== null && _a !== void 0 ? _a : "Ruleset contains no rules files.");
});
