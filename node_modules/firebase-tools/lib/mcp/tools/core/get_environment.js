"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.get_environment = void 0;
const zod_1 = require("zod");
const tool_1 = require("../../tool");
const util_1 = require("../../util");
const projectUtils_1 = require("../../../projectUtils");
const js_yaml_1 = require("js-yaml");
const auth_1 = require("../../../auth");
const configstore_1 = require("../../../configstore");
const appUtils_1 = require("../../../appUtils");
exports.get_environment = (0, tool_1.tool)({
    name: "get_environment",
    description: "Use this to retrieve the current Firebase **environment** configuration for the Firebase CLI and Firebase MCP server, including current authenticated user, project directory, active Firebase Project, and more.",
    inputSchema: zod_1.z.object({}),
    annotations: {
        title: "Get Firebase Environment Info",
        readOnlyHint: true,
    },
    _meta: {
        requiresAuth: false,
        requiresProject: false,
    },
}, async (_, { projectId, host, accountEmail, rc, config }) => {
    const aliases = projectId ? (0, projectUtils_1.getAliases)({ rc }, projectId) : [];
    const geminiTosAccepted = !!configstore_1.configstore.get("gemini");
    const projectFileExists = config.projectFileExists("firebase.json");
    const detectedApps = await (0, appUtils_1.detectApps)(process.cwd());
    const allAccounts = (0, auth_1.getAllAccounts)().map((account) => account.user.email);
    const hasOtherAccounts = allAccounts.filter((email) => email !== accountEmail).length > 0;
    const projectConfigPathString = projectFileExists
        ? config.path("firebase.json")
        : "<NO CONFIG PRESENT>";
    const detectedAppsMap = detectedApps
        .filter((app) => !!app.appId)
        .reduce((map, app) => {
        if (app.appId) {
            map.set(app.appId, app.bundleId ? app.bundleId : "<UNKNOWN BUNDLE ID>");
        }
        return map;
    }, new Map());
    const activeProjectString = projectId
        ? `${projectId}${aliases.length ? ` (alias: ${aliases.join(",")})` : ""}`
        : "<NONE>";
    const acceptedGeminiTosString = geminiTosAccepted ? "Accepted" : "<NOT ACCEPTED>";
    return (0, util_1.toContent)(`# Environment Information

Project Directory: ${host.cachedProjectDir}
Project Config Path: ${projectConfigPathString}
Active Project ID: ${activeProjectString}
Gemini in Firebase Terms of Service: ${acceptedGeminiTosString}
Authenticated User: ${accountEmail || "<NONE>"}
Detected App IDs: ${detectedAppsMap.size > 0 ? `\n\n${(0, js_yaml_1.dump)(Object.fromEntries(detectedAppsMap)).trim()}\n` : "<NONE>"}
Available Project Aliases (format: '[alias]: [projectId]'): ${Object.entries(rc.projects).length > 0 ? `\n\n${(0, js_yaml_1.dump)(rc.projects).trim()}\n` : "<NONE>"}${hasOtherAccounts ? `\nAvailable Accounts: \n\n${(0, js_yaml_1.dump)(allAccounts).trim()}` : ""}
${projectFileExists
        ? `\nfirebase.json contents:

\`\`\`json
${config.readProjectFile("firebase.json")}
\`\`\``
        : `\nNo firebase.json file was found.
      
If this project does not use Firebase services that require a firebase.json file, no action is necessary.

If this project uses Firebase services that require a firebase.json file, the user will most likely want to:

a) Change the project directory using the 'firebase_update_environment' tool to select a directory with a 'firebase.json' file in it, or
b) Initialize a new Firebase project directory using the 'firebase_init' tool.

Confirm with the user before taking action.`}`);
});
