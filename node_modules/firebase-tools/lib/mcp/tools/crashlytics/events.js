"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.batch_get_events = exports.list_events = void 0;
const zod_1 = require("zod");
const tool_1 = require("../../tool");
const util_1 = require("../../util");
const events_1 = require("../../../crashlytics/events");
const types_1 = require("../../../crashlytics/types");
const filters_1 = require("../../../crashlytics/filters");
function pruneThreads(sample) {
    var _a, _b, _c;
    if (((_a = sample.issue) === null || _a === void 0 ? void 0 : _a.errorType) === types_1.ErrorType.FATAL || ((_b = sample.issue) === null || _b === void 0 ? void 0 : _b.errorType) === types_1.ErrorType.ANR) {
        sample.threads = (_c = sample.threads) === null || _c === void 0 ? void 0 : _c.filter((t) => t.crashed || t.blamed);
    }
    return sample;
}
exports.list_events = (0, tool_1.tool)({
    name: "list_events",
    description: `Use this to list the most recent events matching the given filters.
      Can be used to fetch sample crashes and exceptions for an issue,
      which will include stack traces and other data useful for debugging.`,
    inputSchema: zod_1.z.object({
        appId: filters_1.ApplicationIdSchema,
        filter: filters_1.EventFilterSchema,
        pageSize: zod_1.z.number().describe("Number of rows to return").default(1),
    }),
    annotations: {
        title: "List Crashlytics Events",
        readOnlyHint: true,
    },
    _meta: {
        requiresAuth: true,
    },
}, async ({ appId, filter, pageSize }) => {
    if (!appId)
        return (0, util_1.mcpError)(`Must specify 'appId' parameter.`);
    if (!filter || (!filter.issueId && !filter.issueVariantId))
        return (0, util_1.mcpError)(`Must specify 'filter.issueId' or 'filter.issueVariantId' parameters.`);
    const response = await (0, events_1.listEvents)(appId, filter, pageSize);
    response.events = response.events ? response.events.map((e) => pruneThreads(e)) : [];
    return (0, util_1.toContent)(response);
});
exports.batch_get_events = (0, tool_1.tool)({
    name: "batch_get_events",
    description: `Gets specific events by resource name.
      Can be used to fetch sample crashes and exceptions for an issue,
      which will include stack traces and other data useful for debugging.`,
    inputSchema: zod_1.z.object({
        appId: filters_1.ApplicationIdSchema,
        names: zod_1.z
            .array(zod_1.z.string())
            .describe("An array of the event resource names, as found in the sampleEvent field in reports."),
    }),
    annotations: {
        title: "Batch Get Crashlytics Events",
        readOnlyHint: true,
    },
    _meta: {
        requiresAuth: true,
    },
}, async ({ appId, names }) => {
    if (!appId)
        return (0, util_1.mcpError)(`Must specify 'appId' parameter.`);
    if (!names || names.length === 0)
        return (0, util_1.mcpError)(`Must provide event resource names in name parameter.`);
    const response = await (0, events_1.batchGetEvents)(appId, names);
    response.events = response.events ? response.events.map((e) => pruneThreads(e)) : [];
    return (0, util_1.toContent)(response);
});
